module UI where

import Control.Monad ( forever )
import Data.Time.Clock
import System.Exit ( exitSuccess )

-- import Control.Concurrent ( threadDelay )
import Control.Concurrent.STM
import Graphics.Vty
import Graphics.Vty.CrossPlatform (mkVty)

import qualified Sound.Backend.State as E
import Sound.Notes


sendEvent :: TQueue E.TimedEvent -> E.Event -> IO ()
sendEvent queue event = do
    time <- getCurrentTime
    putStrLn "event!!"
    atomically $ writeTQueue queue (E.TimedEvent time event)


runUI :: TQueue E.TimedEvent -> IO ()
runUI queue = do
    vty <- mkVty defaultConfig
    let line0 = string defAttr "This is..."
    let line1 = string defAttr "...the program!"

    let img = line0 <-> line1
    let pic = picForImage img
    update vty pic

    ev <- nextEvent vty
    case ev of
        EvKey (KChar ch) [] -> case keyEventMap ch of
            Just event -> do
                sendEvent queue event
                runUI queue
            Nothing | ch == 'q' -> shutdownUI vty
            Nothing -> runUI queue
        _ -> do
            runUI queue
    where
        keyEventMap key = case key of
            'a' -> Just $ E.NoteSet E.NoteOff
            'z' -> Just $ E.NoteSet (E.NoteOn C)
            's' -> Just $ E.NoteSet (E.NoteOn Db)
            'x' -> Just $ E.NoteSet (E.NoteOn D)
            'd' -> Just $ E.NoteSet (E.NoteOn Eb)
            'c' -> Just $ E.NoteSet (E.NoteOn E)
            'v' -> Just $ E.NoteSet (E.NoteOn F)
            'g' -> Just $ E.NoteSet (E.NoteOn Gb)
            'b' -> Just $ E.NoteSet (E.NoteOn G)
            'h' -> Just $ E.NoteSet (E.NoteOn Ab)
            'n' -> Just $ E.NoteSet (E.NoteOn A)
            'j' -> Just $ E.NoteSet (E.NoteOn Bb)
            'm' -> Just $ E.NoteSet (E.NoteOn B)
            'o' -> Just E.OctaveDown
            'p' -> Just E.OctaveUp
            _   -> Nothing


shutdownUI :: Vty -> IO ()
shutdownUI vty = do
    shutdown vty
